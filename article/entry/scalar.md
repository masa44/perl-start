
---
#スカラー

---
###基本的なデータ型
Perlでは**スカラー**が基本的なデータ型となり、これは1つの値を保持できるデータのことを指します(ほとんどの場合、数値と文字列のことです。)  

---
###スカラー変数
変数の宣言には、`$`を用います。

	use strict;  
	use warnings;  
	my $x = 123;  

これを**スカラー変数**といいます。  
右辺の`123`は**リテラル**と呼び、ソースコード上で直接書かれた値のことを指します。  

`my`は、変数を新たに使用する際に必ず必要となるものです。
これは、一番はじめに書かれた`strict`によるもので、右辺に値を指定しない場合は**undef(未定義値)**が設定されます。

####整数の表し方
数値リテラルには"_"を含めることができ、桁数が多い数値を入れる場合などに使われます。  
たとえば、以下の書き方はどちらも同じ値 "10000000" が入ります。

	my $x = 10000000;  
	my $y = 10_000_000;

---
###変数名のルール
変数名には、以下のルールに従って決める必要があります。  

* *1文字目は英字からはじまる*
* *2文字目以降は英字・数字・アンダースコア（_）が使用可能*
* *大文字と小文字は区別される*

これをコードで表すと…

	my $abc123;     # OK
	my $123abc;     # NG(数字からはじまるためエラー)
	my $abc_123;	# OK
	my $abc-123;	# NG(ハイフンは使用できません)

---
###数値用演算子
四則演算子`+-*/` と剰余演算子`%`、べき乗演算子`**` が使えます。

	my $x = 1 + 1;		# 加算
	my $y = 100 - 90;	# 減算
	my $z = 30 * 40;	# 乗算
	my $w = 99 / 3;		# 除算
	my $v = 10 % 3;		# 剰余
	my $u = 2 ** 3;		# べき算

また、オートインクリメント・オートデクリメント演算子というものもあります。
オートインクリメント演算子は置くと値を返す前に変数の値を1増やし、オートデクリメント演算子は置くと値を返す前に変数の値を1減らすことができます。

	my $foo = 10;

	++$foo;		# オートインクリメント演算子（前）、fooは11
	$foo++;		# オートインクリメント演算子（後）、fooは12

	--$foo;		# オートデクリメント演算子（前）、fooは11
	$foo--;		# オートデクリメント演算子（後）、fooは10

演算子の前後の違いは、増減させるタイミングです。  
前に置いた場合、先に1足して（減らして）から`$foo`の値を使用しますが、後に置いた場合は`$foo`の値が使用された後に1足す（減らす）ことになります。

---
###if文と比較演算子
数値の比較には等値演算子`==, !=, <=>` と関係演算子`<, >, <=, >=` を使います。  
これらはすべて比較演算子と呼びます。  
`<=>`以外の演算子は、真なら1、偽なら""を返します。

	$x > $y		# $xは$yより大きい
	$x >= $y	# $xは$yより大きいか等しい
	$x < $y		# $xは$yより小さい
	$x <= $y	# $xは$yより小さいか等しい
	$x == $y	# $xと$yは等しい
	$x != $y	# $xと$yは等しくない
	$x <=> $y	# $x==$yなら0, $x<$yなら−1, $x>$yなら1

比較演算子はほとんどの場合`if`文で使われます。

	if ($x == 1) {
		say '==';
	} elsif ($x <= 1) {
		say '<=';
	} else {
		say 'else';
	}

if文は条件式が真の場合、ブロック("{ }"の間)を実行する処理です。  
複数処理を記述する場合は`elsif`を使用します。`elsif`は複数書くことができ、条件式を上から順番に実行し、当てはまった条件式のブロックが実行されます。

	if (条件式1) {
		条件式1が真のときに実行する処理;
	} elsif (条件式2) {
		条件式2が真のときに実行する処理;
	} else {
		すべての条件式に当てはまらなかったときに実行する処理;
	}
また、条件が1つのみの場合は、以下のようにブロックを省略して書くこともできます。

	say 'abc' if $x == 1;


---
###ブール値
if文の条件式は、真か偽で判定できる値を指す**ブール値**で評価されます。
Perlでは真偽の判定は以下の規則に従います。

* ""と"0"を除き、すべての文字列は真
* 0を除き、すべての数値は真
* すべてのリファレンス(後述)は真
* すべての未定義値は偽

---
###unless文
unless文は**条件式が偽の場合に**ブロックを実行する処理です。

	my $x = 1;

	unless ($x == 1) {	# $xが1でなければ実行
		say 'unless';
	}
これは、`if ($x != 1)`と同様の条件文です。  
また、unless文もブロックを省略した形で書くことができます。

	say 'abc' unless $x == 1;

---
###文字列リテラル
既に前の節で出ているように、文字列を表す場合は、`''`(シングルクォート)もしくは`""`(ダブルクォート)で囲みます。

####シングルクォート文字列
シングルクォートで囲まれた文字列は、`'`と`\`を除き、囲まれた文字の内容がそのまま文字列の内容になります。  
この2つの文字を文字列としたい場合、それぞれの文字の前に`\`をつけることで対応できます。

	my $foo = 'foo';
	my $bar = 'bar\'';	# bar'
	my $baz = 'baz\\';	# baz\
	my $boo = 'boo\n';	# boo\n

一番最後の`\n`は、Unix環境で改行を表す記述です(**改行コード**)。  
この例ではシングルクォートで囲んでいるため、改行コードと認識されず、そのまま文字列となります。

####ダブルクォート文字列
ダブルクォートで囲まれた文字列は、`\`ではじまる特殊な文字(**エスケープシーケンス**)を認識します。  
代表例として、先述した改行コードがあります。

	my $bar = "bar";
	my $baz = "baz\n";	# \nで改行する

ダブルクォート文字列にスカラー変数を記述すると、その変数の値が展開されます。

	my $bar = "bar";
	my $foo_bar = "foo$bar";	# foobar

変数名の直後に英数字が入り、変数名と文字列が混在するのを防ぐためには変数名をブレース`{}`で囲みます。

	my $bar = "bar";
	my $bar_foo = "$barfoo";	# $barfooを展開しようとして、エラーになる
	my $bar_foo = "${bar}foo";	# $barが正しく展開される

---
###文字列演算子
Perlでは文字列に対しても演算ができます。  
####連結
文字列を連結するには、**文字列連結演算子**を使用します。  
**ピリオド**（`.`）を連結したい文字列の間に入れることで連結されます。数値が与えられた場合は、文字列化して連結されます。

	my $foo = 'foo';
	my $bar = 'bar';
	my $baz = $foo . $bar;	# 'foo'と'bar'を連結して'foobar'となる
	
	$foo = 10;
	$bar = 20;
	$baz = $foo . $bar;		# '1020'となる

####繰り返し
`x + 回数`で文字列を回数分繰り返すことができます。

	my $foo = 'foo';
	$foo x 3;			# 'foofoofoo'

---
###substr関数
substr関数は、文字列を操作する関数です。  
指定した位置から指定文字数を取り出す場合にも使用します。

	substr (STRING(文字列), OFFSET(開始位置), LEN(長さ))

文字列STRINGのOFFSETバイトから、LENバイト取り出して返します。  
OFFSETは、最初を0として数えます。負の数を指定した場合は、STRINGの末尾から数えます。  

	my $foo = 'Hello, World';
	my $bar = substr($foo, 0, 5);	
	say $bar;								# barは'Hello'
	
	my $baz = substr($foo, -5, 5);
	say $baz;								# bazは'World'

---
###length関数
length関数は、対象の文字列のバイト数を返します。

	my $foo = 'Hello, World';
	print length($foo);			# 12

扱う文字列をutf8で指定している場合、length関数で戻される値は**バイト数ではなく文字数**になります。

	use utf8;
	my $foo = '今日は晴れ';
	print length($foo);			# 5

---
###while文
while文は、条件式が真である間ブロックの処理を繰り返す関数です。

	while (条件式) {
		条件式が真の間繰り返される処理;
	}

次の処理は、いずれも`$i`が1000を超えるまで実行する例です。

	my $i = 0;
	while ($i < 1000) {
		# 100回繰り返されたらループを終了する
		last if $i == 100;
		$i++;
		say $i;
	}
	
	$i = 0;
	while ($i < 1000) {
		$i++;
		# 奇数の時はsayの処理まで実行せず、次のループまでスキップする
		next if $i % 2;
		say $i;
	}

ここで、`last`と`next`が出てきました。これはどちらも、ループの処理を変更したい場合に使用する命令文です。
`last`は、**強制的にループから抜ける**よう指定し、`next`は**強制的に次のループまでスキップする**ときに使用します。
